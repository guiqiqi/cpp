1. **Различие в подходах к разработке компьютерных приложений (Структурное программирование и Объектно-ориентированное программирование).**

    Ориентированное на процесс - это идея программирования, ориентированная на процесс. 

    Сначала он анализирует шаги, необходимые для решения проблемы, а затем использует функции для пошагового выполнения этих шагов и вызывает их по очереди при их использовании. 

    Это базовое последовательное мышление. 

    Метод разработки, ориентированный на процесс, представляет собой абстракцию базовой структуры компьютера. 

    Он делит программу на две части: данные и манипулирование данными. 

    Основной проблемой является разработка и оптимизация структур данных и алгоритмов.

    **Классы: определение, область действия.**

    Область видимости (scope) представляет часть программы, в пределах которой можно использовать объект. Как правило, область видимости ограничивается блоком кода, который заключается в фигурные скобки В зависимости от области видимости создаваемые объекты могут быть глобальными, локальными или автоматическими.

    Основное назначение классов - описывать объекты реального мира, а следовательно проектирование класса эквивалентно моделированию.

    **Структуры в С и С++.**

    Мы используем struct для представления структуры на языке C и используем class в C++.

    C++предоставляет функции управления доступом и ООП для структуры классов.

    ---

2. **Последовательность преобразований исходного кода на языке C++ в исполняемый (машинный) код.** 

    Компилятор преобразует исходный код C ++ в последовательность машинного кода, этот процесс называется компиляцией.

    Процесс можно разделить на несколько частей:

    Предварительная обработка, сборка, компоновка

    **Основные концепции ООП.** 

    Данные содержватся в самом объекте, как в капсуле. 

    Главный принцип ООП - не получайте посредством объекта данные, необходимые для совершения операции. 

    Вместо этого "попросите" объект содержащий данные сделать эту операцию для Вас. 

    Этот принцип называется делегированием.

    **Понятие класса в С++.** 

    Компилятор извлекает из класса следующую информацию: новый пользовательский тип данных;

    имена и типы членов класса, включая типы переменных и прототипы функций;

    спецификаторы доступа (ограничения по использованию функций и переменных класса).

    **Инкапсуляция, наследование, полиморфизм.**

    Инкапсуляция - каждый класс представляет уникальный набор данных и операций (методов) над этими данными.

    Наследование - возможность добавления в класс новых свойств на основе базовых классов.

    Полиморфизм - получение разного поведения объектов во время выполнения посредством одного и того же кода.

    ---

3. **Доступ к элементам класса: управление доступом, функции доступа.** 

    Каждый уровень доступа к данным и функциям определяется ключевыми словами `public, private, protected`.

    Не обязательно для каждого члена класса указывать спецификатор доступа.

    По умолчанию объявлены как `private`.

    Секции с одним и тем же ключевым словом может быть сколько угодно и идти они могут в любом порядке.

    `private` и `protected` члены другого объекта такого же класса будут внутри всех методов класса.

    **Инициализация объектов класса: конструкторы. деструкторы.** 

    Конструктор - Метод, который вызывается компилятором автоматиечски при создании объекта.

    - нельзя вызвать явно, как обычный метод;

    - имя конструктора всегда сопадает с именем класса;

    - у конструктора отсутсвует тип возвращаемого значения, даже void;

    - конструктор не может быть константным, виртуальным или статическим методом.

    Деструктор

    - в большинстве случаев вызывается компилятором неявно; 

    - можно вызвать явно, как метод;
    - имя деструктора совпадает с именем класса, но с символом ~;

    - не принимает параметров и ничего не возвращает; 

    - не может быть константным или статическим; 

    - может быть виртуальным.

    **Константные объекты и функции-элементы класса, вложенность классов, указатель this.** 

    Мы можем включить другой экземпляр класса в качестве переменной-члена класса.

    Указатель this формируется компилятором внутри нестатических методов, следовательно использовать его можно только внутри класса.

    Для класса A тип указателя this - `A* const`.

    **Динамическое распределение памяти.**

    Динамическая память находится в куче памяти программы.

    Динамически выделяемая память не управляется автоматически компилятором, и программист должен освободить ее вручную. Как правило, динамическая память необходима, когда размер используемой памяти неизвестен.

    ---

4. **Указатели и массивы.**

    Имя массива в языке С фактически является указателем на первый его элемент, который соответствует нулевому значению индекса. Если объявлен массив `float a[16];`, то справедливо равенство `а==&a[0]`.

    **Многомерные массивы.**

    Суть многомерного массива - это массив указателей, в котором хранятся адреса первых элементов других массивов.

    **Массивы указателей.**

    Массив указателя означает, что тип элемента хранения в массиве является типом указателя, обычно они используются в многомерных массивах.

    Кроме того, при использовании new для создания объекта в памяти кучи вы можете использовать массив для хранения указателя объекта, чтобы облегчить освобождение объекта.

    **Указатели и ссылки на объекты.** 

    Суть указателя - это тип данных типа unsigned int, в котором хранится адрес объекта; при использовании указателя компилятор выделяет для него память.

    Использование ссылок не требует выделения для них избыточной памяти, а операции с объектом будут напрямую влиять на сам исходный объект.

    Кроме того, когда мы используем sizeof для управления ссылкой, мы получим размер исходного объекта.

    **Операции приведения типов.** 

    Преобразование типов в C ++ имеет следующие типы:

    `static_cast`

    - во время компиляции, то же, что и приведение типов в языке C

    `dynamic_cast`

    - повышающее - приведение производного класса к базовому
    - понижающее - из базового класса в производный 
    - перекрестное - приведение между производными типами

    `const_cast`

    - во время компиляции

    - используется для изменения атрибута `const / violate` переменной

    `reinterpret_cast`

    - во время компиляции
    - меняется только тип указателя, исходные данные не обрабатываются

    **Способы обработки исключительных ситуаций.**

    При обработке рассматриваются только ситуации внутреннего характера (нет памяти в области heap, не найден файл, переполнение и т.д.). 

    Ситуация созданная нажатием Ctrl-C считается внешней.

    Синтаксис исключений:

    ```c++
    try { 
      //... 
    }
    ```

    Генерация исключений:

    ```c++
    throw [ 
      //выражение 
    ] ;
    ```

    Обработка исключений:

    ```c++
    catch ( 
    	//тип имя 
    )
    catch (
    	//тип
    )
    catch () {
    	// тело обработчика
    }
    ```

    После обработки исключения управление передается первому оператору находящемуся за блоком исключений. Туда же, минуя код всех обработчиков, передается управление, если исключение в try-блоке не было сгенерировано.

    При генерации исключений:

    - создается копия параметра throw в виде объекта, который существует до тех пор, пока исключение не будет обработано;
    - вызываются деструкторы объектов выходящих из области дейстия;
    - передается объект и управление обработчику имеющему совместимый тип с этим объектом.

    Обработчик считается найденым, если:

    - тип объекта в обработчеке тот же, что и указан после throw, т.е. `T, const T, T&, const T&`, где `T` - тип исключения;

    - является производным от указанного в параметре catch, если наследования производилось с ключем `public`;

    - является указателем который может быть преобразован к нужному типу, например `void*`

    Если происходит вызов непредусмотренного исключения, то вызывается функция `unexpected()`, реализацию которой можно заменить при помощи `set_unexpected()`, если такой функции нету, то вызывается функция `terminate()`, реализацию которой можно заменить при помощи `set_terminate()`, если такой функции нету то происходит вызов функции `abort()`.

    ---

5. **Передача объектов в функции.**

    В языках С и C++, в отличие от многих других языков, передача параметров осуществляется по значению - это значит что в функции происходит работа с копией переменной.

    Если вы хотите уменьшить накладные расходы памяти во время передачи объекта или изменить содержимое исходного объекта в функции, вы можете использовать перенос указателя / перенос ссылки.

    **Возвращение объектов.**

    Как и переданное значение, возвращаемое значение также копируется. Следует отметить, что при возврате ссылки или указателя на локальную переменную внутри функции это может вызвать ошибку.

    **Модификаторы доступа и дружественные функции, дружественные классы.**

    Каждый уровень доступа к данным и функциям определяется ключевыми словами `public, private, protected`.

    Не обязательно для каждого члена класса указывать спецификатор доступа.

    По умолчанию объявлены как `private`.

    Секции с одним и тем же ключевым словом может быть сколько угодно и идти они могут в любом порядке.

    `private` и `protected` члены другого объекта такого же класса будут внутри всех методов класса.

    **Переопределение операций.**

    Способы перегрузки операторов:

    - Унарные операторы:

        - метод класса без параметров;

        - глобальная функция с одним параметром.

    - Бинарные операторы:

        - метод класса с одним параметром; 

        - глобальная функция с двумя параметрами.

    Заметка

    - Нельзя создавать собственные операторы, а можно перегружать только существующие;

    - перегруженный оператор действует только по отношению к объектам того класса, для которого он переопределен;

    - нельзя менять число операндов оператора;

    - перегруженные операторы наследуют приоритеты и ассоциативность от встроенных операторов;

    - оператор перегружается только относительно пользовательского типа данных;

    - нельзя перегружать операторы: `. :: .* ? :`

    - как любая другая функция оператор может быть перегружен несколько раз, быть вирульаным или чисто виртуальным;

    - не существует ограничений на тип возвращаемого значения.

    **Операции в виде методов класса и в виде дружественных функций.**

    Функции-члены класса имеют право изменять переменные внутри класса.

    Статические переменные класса могут быть изменены только статическими функциями.

    Функция-член `const` не может изменять переменные внутри класса.

    Дружественные функции определены вне класса, а доступ к переменным частного уровня внутри класса достигается с помощью ключевого слова `friend`.

    ---

6. **Особенности переопределение унарныхи бинарных операций.**

    

    **Наследование: базовые и производные классы.**

    

    **Переопределение элементов базового класса. Модификаторы наследования и модификаторы доступа, их сочетание.**

    ---

7. **Прямые и косвенные базовые классы, множественное наследование.** 

     

    **Конструкторы и деструкторы производных классов, неявный и явный вызовы.** 

    

    **Виртуальные функции, динамическое связывание, деструкторы.** 

    

    **Абстрактные классы.**

    ---

8. **Потоковый ввод-вывод, функции работы с потоками.**

    Файловые потоки:

    - `ifstream` - входной файловый поток 
    - `ofstream` - выходной файловый поток 
    - `fstream` - двунаправленный

    Строковые потоки:

    - `istringstream` - входные строковые потоки; 
    - `ostringstream` - выходные строковые потоки; 
    - `stringstream` - двунаправленные строковые потоки.

    Класс может поддерживать потоковый ввод и вывод путем перегрузки `operator<</>>`.

    **Классы и объекты потоков ввода-вывода (библиотеки STL).** 

    Многие встроенные объекты STL реализуют поддержку потокового ввода и вывода, например `std ::string`.

    ```c++
    std::string str("Hello World!");
    std::cout << str << std::endl;
    ```

    **Ввод-вывод типов данных, определенных пользователем.** 

    В определяемом пользователем типе поддержка потокового ввода и вывода может быть реализована путем перегрузки функции `operator <</>>` класса.

    Следует отметить, что в процессе перегрузки необходимо использовать дружественные функции.

    ```c++
    friend std::ostream& operator<< (std::ostream&, mclass&);
    ```

    **Методы работы с файлами.**

    Сначала используйте поток дескриптора файла для инициализации потока файла (может быть входным или выходным), а затем прочитайте и запишите поток.

    Обычно буфер необходим для временного сохранения данных.

    ```c++
    char buffer[100];
    std::ifstream handler("file.txt", ios::in | ios::nocreate);
    if (!handler) cout << "error";
    while (!handler.eof())
    	handler.getling(buffer, 100);
    ```

    По мере чтения и записи внутри дескриптора указатель файла изменяется.

    ---

9. **Особенности работы со строками текста.**

    Строковый класс - это специальный контейнер данных, который хранит внутри массив типа char для представления строк.

    **Класс string библиотеки STL.**

    Класс string входит в стандартную библиотеку C++.

    Он реализует итератор и поддержку ввода и вывода одновременно.

    **Пример разбора текста.**

    ```c++
    std::string str("This is a test");
    ```

    **Шаблоны функций, переопределение функций шаблона.**

    Шаблоны используются для:

    - Обобщения действий (шаблоны функций). 
    - Обобщение наборов данных (шаблоны классов).

    - Главное достоинство - позволяет уменьшить количество “дублирующегося кода”. 

    Используемые типы становятся известны на этапе компиляции, поэтому компилятор проверяет соответствие (type safe).

    Видя объявление шаблона, компилятор не создает никакого кода. Только встретив обращение к данному шаблону (вызов функции или создание эккземпляра класса), компилятор сгенерирует соответсвующий код.

    Для обозначения обобщенного параметра рекомендуется использовать ключевое слово typename вместо `class`.

    В качестве обобщенного типа можно задать как имя пользовательского типа данных, так и базового.

    Можно задавать значение параметров шаблона по умолчанию.

    Часто говоря о шаблонах употребляют следующие термины: Инстанцирование - подстановка реальных типов в качстве параметров шаблона.

    Специализация - версия шаблона для конкретного набора параметров.

    ---

10. **Шаблоны классов.**

    Шаблоны используются для:

    - Обобщения действий (шаблоны функций). 
    - Обобщение наборов данных (шаблоны классов).

    - Главное достоинство - позволяет уменьшить количество “дублирующегося кода”. 

    Используемые типы становятся известны на этапе компиляции, поэтому компилятор проверяет соответствие (type safe).

    Видя объявление шаблона, компилятор не создает никакого кода. Только встретив обращение к данному шаблону (вызов функции или создание эккземпляра класса), компилятор сгенерирует соответсвующий код.

    Для обозначения обобщенного параметра рекомендуется использовать ключевое слово typename вместо `class`.

    В качестве обобщенного типа можно задать как имя пользовательского типа данных, так и базового.

    Можно задавать значение параметров шаблона по умолчанию.

    Часто говоря о шаблонах употребляют следующие термины: Инстанцирование - подстановка реальных типов в качстве параметров шаблона.

    Специализация - версия шаблона для конкретного набора параметров.

    **Пример разработки шаблона универсальной коллекции типа array (list).**

    ```c++
    template <typename T> class list {
    private:
    	list<T>* next;
    };
    ```

    ---

11. **Статические члены класса.** 

     Как и обычные статические переменные, статическим переменным класса выделяется память, когда программа инициализируется и сохраняется в области статических переменных.

     Это означает, что их модификация вызовет глобальное изменение.

     Статические переменные класса размещаются в статической области памяти, в независимости от того где располагается объект. Существуют в единственном экземпляре.

     Статическую переменную необходимо явно определить независимо от спецификатора доступа.

     При обращении к статической переменной класса, можно обращаться к ней, как к глобальной переменной заключенной в пространство имен (без создания объекта), но т.к. она входит в класс, можно работать с ней и посредством созданного объекта.

     Не следует инициализировать статические переменные в конструкторе, иначе есть опасность каждый раз при обращении получать одно и тоже значение.

     В константных методах, можно можифицировать статические переменные класса.

     **Особенности определения.** 

     Специализация шаблона относится к коду реализации специального соглашения, когда заданы некоторые / все параметры шаблона функции / класса шаблона.

     ```c++
     template <typename T> class list;
     template <> class list<char>;
     ```

     **Пространства имен в C++.** 

     Чтобы облегчить совместную разработку крупномасштабных приложений программистами, C ++ вводит концепцию пространств имен.

     Переменные / классы с одинаковыми именами в разных пространствах имен различаются.

     Мы также можем добавлять имена в пространство имен во время выполнения.

     **Компоненты библиотеки STL.** 

     - Контейнеры

     - Итераторы

     - Аллокаторы

     - Обобщенные алгоритмы

     - Адаптеры

     - Предикаты

     **Контейнеры STL.**

     Последовательные контейнеры:

      - `vector` - структура, эффективно реализующая произвольныей доступ к элементам, а также добавление в конец и удаление из конца;

      - `dequeue` - структура, эффективно реализующая произвольныей доступ к элементам, а также добавление в оба конеца и удаление из обоих концов;

      - `list` - список, эффективно реализует вставку и удаление элементов в произвольное место, но не имеет произвольного доступа к своим элементам.

      Ассоциативные контейнеры: 

      - `map` - словарь

      - `multimap` - словарь с дубликатами

     ---

12. **Методы обработки ошибок в С++.** 

      При обработке рассматриваются только ситуации внутреннего характера (нет памяти в области heap, не найден файл, переполнение и т.д.). 

     Ситуация созданная нажатием Ctrl-C считается внешней.

     Синтаксис исключений:

     ```c++
     try { 
       //... 
     }
     ```

     Генерация исключений:

     ```c++
     throw [ 
       //выражение 
     ] ;
     ```

     Обработка исключений:

     ```c++
     catch ( 
     	//тип имя 
     )
     catch (
     	//тип
     )
     catch () {
     	// тело обработчика
     }
     ```

     После обработки исключения управление передается первому оператору находящемуся за блоком исключений. Туда же, минуя код всех обработчиков, передается управление, если исключение в try-блоке не было сгенерировано.

     При генерации исключений:

     - создается копия параметра throw в виде объекта, который существует до тех пор, пока исключение не будет обработано;
     - вызываются деструкторы объектов выходящих из области дейстия;
     - передается объект и управление обработчику имеющему совместимый тип с этим объектом.

     Обработчик считается найденым, если:

     - тип объекта в обработчеке тот же, что и указан после throw, т.е. `T, const T, T&, const T&`, где `T` - тип исключения;

     - является производным от указанного в параметре catch, если наследования производилось с ключем `public`;

     - является указателем который может быть преобразован к нужному типу, например `void*`

     Если происходит вызов непредусмотренного исключения, то вызывается функция `unexpected()`, реализацию которой можно заменить при помощи `set_unexpected()`, если такой функции нету, то вызывается функция `terminate()`, реализацию которой можно заменить при помощи `set_terminate()`, если такой функции нету то происходит вызов функции `abort()`.

     **Генерация и перехват исключений, обработчики исключений.** 

     > ***Same as previous one***

     **Классы-индикаторы исключений, иерархия исключений.**

     C++ предоставляет серию стандартных исключений, определенных в `exception`, мы можем использовать эти стандартные исключения в программе. Они организованы в иерархию родительских и дочерних классов, как показано ниже:

     ![Exception](https://www.runoob.com/wp-content/uploads/2015/05/exceptions_in_cpp.png)

     ---

13. **Итераторы, их типы и применение (библиотека STL).** 

    Итератор - это специальный класс, который может помочь нам получить доступ к данным внутри класса контейнера. 

    В STL есть класс итератора, который поддерживает большинство контейнеров данных.

    Итератор обычно содержит индекс текущего доступа к контейнеру.
    
    Для их использования необходимо инициализировать итератор в классе контейнера, например:
    
    ```c++
std::vector<char>::iterator
    ```
    
    Итераторы можно разделить на четыре типа:
    
    - Вперед итератор
    - Постоянный прямой итератор
    - Обратный итератор
    - Постоянный обратный итератор
    
    **Примеры использования класса vector (библиотека STL).** 
    
    ```c++
     std::vector<int> vi;
     vi.push_back(10);
     for (auto& item: vi) cout << item;
    ```
    
    **Типизированные и обобщенные последовательности (коллекции) данных.**

