1. **Различие в подходах к разработке компьютерных приложений (Структурное программирование и Объектно-ориентированное программирование).**

    Ориентированное на процесс - это идея программирования, ориентированная на процесс. 

    Сначала он анализирует шаги, необходимые для решения проблемы, а затем использует функции для пошагового выполнения этих шагов и вызывает их по очереди при их использовании. 

    Это базовое последовательное мышление. 

    Метод разработки, ориентированный на процесс, представляет собой абстракцию базовой структуры компьютера. 

    Он делит программу на две части: данные и манипулирование данными. 

    Основной проблемой является разработка и оптимизация структур данных и алгоритмов.

    **Классы: определение, область действия.**

    Область видимости (scope) представляет часть программы, в пределах которой можно использовать объект. Как правило, область видимости ограничивается блоком кода, который заключается в фигурные скобки В зависимости от области видимости создаваемые объекты могут быть глобальными, локальными или автоматическими.

    Основное назначение классов - описывать объекты реального мира, а следовательно проектирование класса эквивалентно моделированию.

    **Структуры в С и С++.**

    Мы используем struct для представления структуры на языке C и используем class в C++.

    C++предоставляет функции управления доступом и ООП для структуры классов.

    ---

2. **Последовательность преобразований исходного кода на языке C++ в исполняемый (машинный) код.** 

    Компилятор преобразует исходный код C ++ в последовательность машинного кода, этот процесс называется компиляцией.

    Процесс можно разделить на несколько частей:

    Предварительная обработка, сборка, компоновка

    **Основные концепции ООП.** 

    Данные содержватся в самом объекте, как в капсуле. 

    Главный принцип ООП - не получайте посредством объекта данные, необходимые для совершения операции. 

    Вместо этого "попросите" объект содержащий данные сделать эту операцию для Вас. 

    Этот принцип называется делегированием.

    **Понятие класса в С++.** 

    Компилятор извлекает из класса следующую информацию: новый пользовательский тип данных;

    имена и типы членов класса, включая типы переменных и прототипы функций;

    спецификаторы доступа (ограничения по использованию функций и переменных класса).

    **Инкапсуляция, наследование, полиморфизм.**

    Инкапсуляция - каждый класс представляет уникальный набор данных и операций (методов) над этими данными.

    Наследование - возможность добавления в класс новых свойств на основе базовых классов.

    Полиморфизм - получение разного поведения объектов во время выполнения посредством одного и того же кода.

    ---

3. **Доступ к элементам класса: управление доступом, функции доступа.** 

    Каждый уровень доступа к данным и функциям определяется ключевыми словами `public, private, protected`.

    Не обязательно для каждого члена класса указывать спецификатор доступа.

    По умолчанию объявлены как `private`.

    Секции с одним и тем же ключевым словом может быть сколько угодно и идти они могут в любом порядке.

    `private` и `protected` члены другого объекта такого же класса будут внутри всех методов класса.

    **Инициализация объектов класса: конструкторы. деструкторы.** 

    Конструктор - Метод, который вызывается компилятором автоматиечски при создании объекта.

    - нельзя вызвать явно, как обычный метод;

    - имя конструктора всегда сопадает с именем класса;

    - у конструктора отсутсвует тип возвращаемого значения, даже void;

    - конструктор не может быть константным, виртуальным или статическим методом.

    Деструктор

    - в большинстве случаев вызывается компилятором неявно; 

    - можно вызвать явно, как метод;
    - имя деструктора совпадает с именем класса, но с символом ~;

    - не принимает параметров и ничего не возвращает; 

    - не может быть константным или статическим; 

    - может быть виртуальным.

    **Константные объекты и функции-элементы класса, вложенность классов, указатель this.** 

    Мы можем включить другой экземпляр класса в качестве переменной-члена класса.

    Указатель this формируется компилятором внутри нестатических методов, следовательно использовать его можно только внутри класса.

    Для класса A тип указателя this - `A* const`.

    **Динамическое распределение памяти.**

    Динамическая память находится в куче памяти программы.

    Динамически выделяемая память не управляется автоматически компилятором, и программист должен освободить ее вручную. Как правило, динамическая память необходима, когда размер используемой памяти неизвестен.

    ---

4. **Указатели и массивы.**

    Имя массива в языке С фактически является указателем на первый его элемент, который соответствует нулевому значению индекса. Если объявлен массив `float a[16];`, то справедливо равенство `а==&a[0]`.

    **Многомерные массивы.**

    Суть многомерного массива - это массив указателей, в котором хранятся адреса первых элементов других массивов.

    **Массивы указателей.**

    Массив указателя означает, что тип элемента хранения в массиве является типом указателя, обычно они используются в многомерных массивах.

    Кроме того, при использовании new для создания объекта в памяти кучи вы можете использовать массив для хранения указателя объекта, чтобы облегчить освобождение объекта.

    **Указатели и ссылки на объекты.** 

    Суть указателя - это тип данных типа unsigned int, в котором хранится адрес объекта; при использовании указателя компилятор выделяет для него память.

    Использование ссылок не требует выделения для них избыточной памяти, а операции с объектом будут напрямую влиять на сам исходный объект.

    Кроме того, когда мы используем sizeof для управления ссылкой, мы получим размер исходного объекта.

    **Операции приведения типов.** 

    Преобразование типов в C ++ имеет следующие типы:

    `static_cast`

    - во время компиляции, то же, что и приведение типов в языке C

    `dynamic_cast`

    - повышающее - приведение производного класса к базовому
    - понижающее - из базового класса в производный 
    - перекрестное - приведение между производными типами

    `const_cast`

    - во время компиляции

    - используется для изменения атрибута `const / violate` переменной

    `reinterpret_cast`

    - во время компиляции
    - меняется только тип указателя, исходные данные не обрабатываются

    **Способы обработки исключительных ситуаций.**

    При обработке рассматриваются только ситуации внутреннего характера (нет памяти в области heap, не найден файл, переполнение и т.д.). 

    Ситуация созданная нажатием Ctrl-C считается внешней.

    Синтаксис исключений:

    ```c++
    try { 
      //... 
    }
    ```

    Генерация исключений:

    ```c++
    throw [ 
      //выражение 
    ] ;
    ```

    Обработка исключений:

    ```c++
    catch ( 
    	//тип имя 
    )
    catch (
    	//тип
    )
    catch () {
    	// тело обработчика
    }
    ```

    После обработки исключения управление передается первому оператору находящемуся за блоком исключений. Туда же, минуя код всех обработчиков, передается управление, если исключение в try-блоке не было сгенерировано.

    При генерации исключений:

    - создается копия параметра throw в виде объекта, который существует до тех пор, пока исключение не будет обработано;
    - вызываются деструкторы объектов выходящих из области дейстия;
    - передается объект и управление обработчику имеющему совместимый тип с этим объектом.

    Обработчик считается найденым, если:

    - тип объекта в обработчеке тот же, что и указан после throw, т.е. `T, const T, T&, const T&`, где `T` - тип исключения;

    - является производным от указанного в параметре catch, если наследования производилось с ключем `public`;

    - является указателем который может быть преобразован к нужному типу, например `void*`

    Если происходит вызов непредусмотренного исключения, то вызывается функция `unexpected()`, реализацию которой можно заменить при помощи `set_unexpected()`, если такой функции нету, то вызывается функция `terminate()`, реализацию которой можно заменить при помощи `set_terminate()`, если такой функции нету то происходит вызов функции `abort()`.

    ---

5. **Передача объектов в функции.**

    В языках С и C++, в отличие от многих других языков, передача параметров осуществляется по значению - это значит что в функции происходит работа с копией переменной.

    Если вы хотите уменьшить накладные расходы памяти во время передачи объекта или изменить содержимое исходного объекта в функции, вы можете использовать перенос указателя / перенос ссылки.

    **Возвращение объектов.**

    Как и переданное значение, возвращаемое значение также копируется. Следует отметить, что при возврате ссылки или указателя на локальную переменную внутри функции это может вызвать ошибку.

    **Модификаторы доступа и дружественные функции, дружественные классы.**

    Каждый уровень доступа к данным и функциям определяется ключевыми словами `public, private, protected`.

    Не обязательно для каждого члена класса указывать спецификатор доступа.

    По умолчанию объявлены как `private`.

    Секции с одним и тем же ключевым словом может быть сколько угодно и идти они могут в любом порядке.

    `private` и `protected` члены другого объекта такого же класса будут внутри всех методов класса.

    **Переопределение операций.**

    Способы перегрузки операторов:

    - Унарные операторы:

        - метод класса без параметров;

        - глобальная функция с одним параметром.

    - Бинарные операторы:

        - метод класса с одним параметром; 

        - глобальная функция с двумя параметрами.

    Заметка

    - Нельзя создавать собственные операторы, а можно перегружать только существующие;

    - перегруженный оператор действует только по отношению к объектам того класса, для которого он переопределен;

    - нельзя менять число операндов оператора;

    - перегруженные операторы наследуют приоритеты и ассоциативность от встроенных операторов;

    - оператор перегружается только относительно пользовательского типа данных;

    - нельзя перегружать операторы: `. :: .* ? :`

    - как любая другая функция оператор может быть перегружен несколько раз, быть вирульаным или чисто виртуальным;

    - не существует ограничений на тип возвращаемого значения.

    **Операции в виде методов класса и в виде дружественных функций.**

    Функции-члены класса имеют право изменять переменные внутри класса.

    Статические переменные класса могут быть изменены только статическими функциями.

    Функция-член `const` не может изменять переменные внутри класса.

    Дружественные функции определены вне класса, а доступ к переменным частного уровня внутри класса достигается с помощью ключевого слова `friend`.

    ---

6. **Особенности переопределение унарныхи бинарных операций.**

    Унарные операторы:

    - метод класса без параметров;

    - глобальная функция с одним параметром.

    Бинарные операторы:

    - метод класса с одним параметром; 
    - глобальная функция с двумя параметрами.

    Всегда стоит предпочитать перегрузку методом класса, за исключением:

    - первый операнд относится к базовому типу, например, `z = 1 + z`;

    - тип первого операнда библиотечный;

    - операторы `=, (), [], ->` могут быть перегружены только методом класса.

    Порядок поиска компилятором перегруженного бинарного оператора:

    1. если оба аргумента относятся к базовым типам, то используется встроенный оператор;
    2. если слева стоит операнд пользовательского типа, то компилятор ищет оператор в форме метода класса;
    3. если перегрузки в форме метода не найдено или слева стоит операнд базового типа, то компилятор ищет перегрузку в форме глобальной функции;
    4. ошибка при компиляции.

    **Наследование: базовые и производные классы.**

    Наследование - возможность добавления в класс новых свойств на основе базовых классов.

    Спецификатор при наследовании, позволяет задать для базового класса более жесткие ограничения на свойства видимости переменных.

    Унаследованный класс называется базовым классом, а производный класс - подклассом.

    **Переопределение элементов базового класса. Модификаторы наследования и модификаторы доступа, их сочетание.**

    Бывают следующих типов:

    - является (is a). Открытое `public` наследование;
    - содержит (has a). Нет наследования, объект содержит объект другого класса;
    - подобен (as a). Закрытое (`private` или `protected`) наследование.

    Для корректного построения иерархии, программист должен представлять различия между типами взаимоотношений и применять их исключительно по назначению.

    ---

7. **Прямые и косвенные базовые классы, множественное наследование.** 

    Простое наследование - наследование от одного родителя.

    Наследование от нескольких классов называется множественным наследованием, а порядок вызова конструктора родительского класса такой же, как порядок объявления в наследовании.

    **Конструкторы и деструкторы производных классов, неявный и явный вызовы.** 

    Конструкторы вызываются от более старшего класса к младшему, деструкторы наоборот.

    **Виртуальные функции, динамическое связывание, деструкторы.** 

    Если в базовом классе метод виртуальныaй, то в производном классе такойже метод становится автоматически виртуальным.

    Виртуальные методы наследуются. Нельзя объявить как `static`.

    Можно определить вирутальный метод, как "чисто виртуальный" присвоив ему значение `=0`.

    Деструктор базового класса как правило всегда следует делать виртуальным, чтобы избежать утечек памяти.

    **Абстрактные классы.**

    Абстрактный класс - класс имеющий "чисто виртуальные" функции, объект такого класса не может быть создан, а только унаследован.

    Если в объявлении класса появляется виртульная функция, то компилятор формирует таблицу виртуальных функций.

    Каждый объект в дополнении к стандартным полям хранения данных содержит поля для хранения указателя на таблицу виртуальныйх функций - `vfptr`;

    ---

8. **Потоковый ввод-вывод, функции работы с потоками.**

    Файловые потоки:

    - `ifstream` - входной файловый поток 
    - `ofstream` - выходной файловый поток 
    - `fstream` - двунаправленный

    Строковые потоки:

    - `istringstream` - входные строковые потоки; 
    - `ostringstream` - выходные строковые потоки; 
    - `stringstream` - двунаправленные строковые потоки.

    Класс может поддерживать потоковый ввод и вывод путем перегрузки `operator<</>>`.

    **Классы и объекты потоков ввода-вывода (библиотеки STL).** 

    Многие встроенные объекты STL реализуют поддержку потокового ввода и вывода, например `std ::string`.

    ```c++
    std::string str("Hello World!");
    std::cout << str << std::endl;
    ```

    **Ввод-вывод типов данных, определенных пользователем.** 

    В определяемом пользователем типе поддержка потокового ввода и вывода может быть реализована путем перегрузки функции `operator <</>>` класса.

    Следует отметить, что в процессе перегрузки необходимо использовать дружественные функции.

    ```c++
    friend std::ostream& operator<< (std::ostream&, mclass&);
    ```

    **Методы работы с файлами.**

    Сначала используйте поток дескриптора файла для инициализации потока файла (может быть входным или выходным), а затем прочитайте и запишите поток.

    Обычно буфер необходим для временного сохранения данных.

    ```c++
    char buffer[100];
    std::ifstream handler("file.txt", ios::in | ios::nocreate);
    if (!handler) cout << "error";
    while (!handler.eof())
    	handler.getling(buffer, 100);
    ```

    По мере чтения и записи внутри дескриптора указатель файла изменяется.

    ---

9. **Особенности работы со строками текста.**

    Строковый класс - это специальный контейнер данных, который хранит внутри массив типа char для представления строк.

    **Класс string библиотеки STL.**

    Класс string входит в стандартную библиотеку C++.

    Он реализует итератор и поддержку ввода и вывода одновременно.

    **Пример разбора текста.**

    ```c++
    std::string str("This is a test");
    ```

    **Шаблоны функций, переопределение функций шаблона.**

    Шаблоны используются для:

    - Обобщения действий (шаблоны функций). 
    - Обобщение наборов данных (шаблоны классов).

    - Главное достоинство - позволяет уменьшить количество “дублирующегося кода”. 

    Используемые типы становятся известны на этапе компиляции, поэтому компилятор проверяет соответствие (type safe).

    Видя объявление шаблона, компилятор не создает никакого кода. Только встретив обращение к данному шаблону (вызов функции или создание эккземпляра класса), компилятор сгенерирует соответсвующий код.

    Для обозначения обобщенного параметра рекомендуется использовать ключевое слово typename вместо `class`.

    В качестве обобщенного типа можно задать как имя пользовательского типа данных, так и базового.

    Можно задавать значение параметров шаблона по умолчанию.

    Часто говоря о шаблонах употребляют следующие термины: Инстанцирование - подстановка реальных типов в качстве параметров шаблона.

    Специализация - версия шаблона для конкретного набора параметров.

    ---

10. **Шаблоны классов.**

    Шаблоны используются для:

    - Обобщения действий (шаблоны функций). 
    - Обобщение наборов данных (шаблоны классов).

    - Главное достоинство - позволяет уменьшить количество “дублирующегося кода”. 

    Используемые типы становятся известны на этапе компиляции, поэтому компилятор проверяет соответствие (type safe).

    Видя объявление шаблона, компилятор не создает никакого кода. Только встретив обращение к данному шаблону (вызов функции или создание эккземпляра класса), компилятор сгенерирует соответсвующий код.

    Для обозначения обобщенного параметра рекомендуется использовать ключевое слово typename вместо `class`.

    В качестве обобщенного типа можно задать как имя пользовательского типа данных, так и базового.

    Можно задавать значение параметров шаблона по умолчанию.

    Часто говоря о шаблонах употребляют следующие термины: Инстанцирование - подстановка реальных типов в качстве параметров шаблона.

    Специализация - версия шаблона для конкретного набора параметров.

    **Пример разработки шаблона универсальной коллекции типа array (list).**

    ```c++
    template <typename T> class list {
    private:
    	list<T>* next;
    };
    ```

    ---

11. **Статические члены класса.** 

     Как и обычные статические переменные, статическим переменным класса выделяется память, когда программа инициализируется и сохраняется в области статических переменных.

     Это означает, что их модификация вызовет глобальное изменение.

     Статические переменные класса размещаются в статической области памяти, в независимости от того где располагается объект. Существуют в единственном экземпляре.

     Статическую переменную необходимо явно определить независимо от спецификатора доступа.

     При обращении к статической переменной класса, можно обращаться к ней, как к глобальной переменной заключенной в пространство имен (без создания объекта), но т.к. она входит в класс, можно работать с ней и посредством созданного объекта.

     Не следует инициализировать статические переменные в конструкторе, иначе есть опасность каждый раз при обращении получать одно и тоже значение.

     В константных методах, можно можифицировать статические переменные класса.

     **Особенности определения.** 

     Специализация шаблона относится к коду реализации специального соглашения, когда заданы некоторые / все параметры шаблона функции / класса шаблона.

     ```c++
     template <typename T> class list;
     template <> class list<char>;
     ```

     **Пространства имен в C++.** 

     Чтобы облегчить совместную разработку крупномасштабных приложений программистами, C ++ вводит концепцию пространств имен.

     Переменные / классы с одинаковыми именами в разных пространствах имен различаются.

     Мы также можем добавлять имена в пространство имен во время выполнения.

     **Компоненты библиотеки STL.** 

     - Контейнеры

     - Итераторы

     - Аллокаторы

     - Обобщенные алгоритмы

     - Адаптеры

     - Предикаты

     **Контейнеры STL.**

     Последовательные контейнеры:

      - `vector` - структура, эффективно реализующая произвольныей доступ к элементам, а также добавление в конец и удаление из конца;

      - `dequeue` - структура, эффективно реализующая произвольныей доступ к элементам, а также добавление в оба конеца и удаление из обоих концов;

      - `list` - список, эффективно реализует вставку и удаление элементов в произвольное место, но не имеет произвольного доступа к своим элементам.

      Ассоциативные контейнеры: 

      - `map` - словарь

      - `multimap` - словарь с дубликатами

    ---

12. **Методы обработки ошибок в С++.** 

      При обработке рассматриваются только ситуации внутреннего характера (нет памяти в области heap, не найден файл, переполнение и т.д.). 

     Ситуация созданная нажатием Ctrl-C считается внешней.

     Синтаксис исключений:

     ```c++
     try { 
       //... 
     }
     ```

     Генерация исключений:

     ```c++
     throw [ 
       //выражение 
     ] ;
     ```

     Обработка исключений:

     ```c++
     catch ( 
     	//тип имя 
     )
     catch (
     	//тип
     )
     catch () {
     	// тело обработчика
     }
     ```

     После обработки исключения управление передается первому оператору находящемуся за блоком исключений. Туда же, минуя код всех обработчиков, передается управление, если исключение в try-блоке не было сгенерировано.

     При генерации исключений:

     - создается копия параметра throw в виде объекта, который существует до тех пор, пока исключение не будет обработано;
     - вызываются деструкторы объектов выходящих из области дейстия;
     - передается объект и управление обработчику имеющему совместимый тип с этим объектом.

     Обработчик считается найденым, если:

     - тип объекта в обработчеке тот же, что и указан после throw, т.е. `T, const T, T&, const T&`, где `T` - тип исключения;

     - является производным от указанного в параметре catch, если наследования производилось с ключем `public`;

     - является указателем который может быть преобразован к нужному типу, например `void*`

     Если происходит вызов непредусмотренного исключения, то вызывается функция `unexpected()`, реализацию которой можно заменить при помощи `set_unexpected()`, если такой функции нету, то вызывается функция `terminate()`, реализацию которой можно заменить при помощи `set_terminate()`, если такой функции нету то происходит вызов функции `abort()`.

     **Генерация и перехват исключений, обработчики исключений.** 

     > ***Same as previous one***

     **Классы-индикаторы исключений, иерархия исключений.**

     C++ предоставляет серию стандартных исключений, определенных в `exception`, мы можем использовать эти стандартные исключения в программе. Они организованы в иерархию родительских и дочерних классов, как показано ниже:

     ![Exception](https://www.runoob.com/wp-content/uploads/2015/05/exceptions_in_cpp.png)

    ---

13. **Итераторы, их типы и применение (библиотека STL).** 

    Итератор - это специальный класс, который может помочь нам получить доступ к данным внутри класса контейнера. 

    В STL есть класс итератора, который поддерживает большинство контейнеров данных.

    Итератор обычно содержит индекс текущего доступа к контейнеру.
    
    Для их использования необходимо инициализировать итератор в классе контейнера.
    
    Итераторы можно разделить на четыре типа:

    - Вперед итератор
    - Постоянный прямой итератор
    - Обратный итератор
    - Постоянный обратный итератор
    
    **Примеры использования класса vector (библиотека STL).** 
    
    Example:
    
    ```c++
     std::vector<int> vi;
     vi.push_back(10);
     for (auto& item: vi) cout << item;
    ```
    
    **Типизированные и обобщенные последовательности (коллекции) данных.**
    
    В STL есть несколько типов последовательных контейнеров:
    
    - `vector` - Массив, размер которого можно динамически изменять
    - `deque` - Deque
    - `list` - Двусвязный список
    - `array` - Массив фиксированного размера
    - `string` - Контейнер персонажа
    
    ---
    
14. **Лямбда-выражения.** 

    Лямбда-выражениями называются безымянные локальные функции, которые можно создавать прямо внутри какого-либо выражения.

    в C++ - это краткая форма записи анонимных предикатов.

     **Специфика лямбда-выражений.** 

     λ-выражение:

     - всегда начинается с `[]` (скобки могут быть непустыми)
     - затем идет необязательный список параметров
     - параметры можно передавать разными способами (по ссылке, по значению)
     - затем непосредственно «тело функции»
     - по умолчанию λ-функция возвращает `void` (можно указать возвращаемый тип явно)

    **Использование λ- выражений вместо функциональных объектов.** 

     ```c++
     [](int x){cout << (x*x*x) << endl;}
     ```

    **Модификация переменных анонимного функционального объекта внутри λ-функции.**

    Мы можем использовать ссылку для захвата внешней переменной, просто добав спецификатор ссылки и перед переменной списка захвата.

     ```c++
     [&count](unsigned int times)mutable->bool {count += times; return (times > 0);}
     ```

    ---

15. **Семантика перемещения, move-конструктор копирования, move-оператор присваивания.** 

    **Глобальные функции как предикаты в шаблонных функциях в библиотеке STL.** 

    **Функциональные объекты и шаблоны классов как предикаты в шаблонных функциях STL.** 

    **Ключевое слово auto при объявлении типов, примеры.**

    ---

16. **Динамические структуры данных (ассоциативные).** 

    **Сферы использования и особенности функционирования ассоциативных контейнеров.**

    ---

17. **Основные модули в Qt.** 

    Самый простой модуль в Qt - это QObject, и все классы являются производными от него.

    **Иерархия объектов в Qt.** 

    Для построения иерархий необходимо использовать классы, рожденные от `QObject`. Объекты классов должны создаваться динамически.

    Класс `QObject` содержит реализацию всех необходимых методов для организации иерархий объектов. Конструктор `QObject` выглядит следующим образом:

     ```c++
     QObject(QObject* parent=nullptr);
     ```

    Одно из основных достоинств иерархий объектов ￿ это автоматическое удаление всех дочерних объектов при удалении корневого объекта. Разработчику достаточно удалить только те объекты, которые являются вершинами.

     Методы QObject для работы с иерархиями:

     - `setParent()` - позволяет задать нового родителя.
     - `parent()` - возвращает указатель на текущего родителя.
     - `children()` - возвращает указатель на список дочерних объектов.
     - `findChildren()` - позволяет искать дочерние объекты по имени (поддерживаются регулярные выражения).
     - `dumpObjectInfo()` - отображает отладочную информацию об иерархии.
     - `setObjectName()/objectName()` - задать/получить имя объекта.

    **Концепция сигналов и слотов.** 

    Сигналы и слоты - это фундаментальный механизм Qt, позволяющий связывать объекты друг с другом. Cвязанным объектам нет необходимости что-либо ￿знать￿ друг о друге. Сигналы и слоты гораздо удобнее механизма функций обратного вызова (callbacks) и четко вписываются в концепцию ООП.

    Для использования этого механизма объявление класса должно содержать специальный макрос Q_OBJECT на следующей строке после ключевого слова class.

    После макроса Q_OBJECT не нужно ставить точку с запятой. Перед выполнением компиляции, Meta Object Compiler (MOC) анализирует такие классы и автоматически внедряет в них всю необходимую информацию.

    **Преимущества их использования.** 

    Для того чтобы инициировать сигнал (выслать сигнал) нужно ипользовать ключевое слово emit.

    Сигналы могут использовать параметры для передачи дополнительной информации.

    Слоты практически идентичны обычным членам-методам C++, при их объявлении можно использовать стандартные спецификаторы доступа `public, protected` или `private`.

    **Подключение сигналов и слотов.**

    Для соединения сигналов и слотов можно использовать статический метод connect, определенный в классе `QObject`. Один сигнал может быть соединен со многими слотами, а так же множество сигналов могут быть соединены с единственным слотом.

    `sender` и `receiver` - это указатели на `QObject`. `signal` и `slot` - сигнатуры сигнала и слота.

    ---

18. **Система сборки qmake.** 

     `qmake` имеет два режима работы, в первом он генерирует проектные файлы (.pro), а во втором на основе проектных файлов генерирует правила сборки. 

     Опции:

     - -recursive
     - -nodepend
     - -nomoc
     - -Wnone
     - -Wall

     В файле проекта, переменные используются для хранения списков строк. В простых проектах эти переменные информируют qmake о параметрах настройки, именах файлов и каталогах, которые используются в процессе сборки.

     **Пользовательские и встроенные переменные.**

     Специальный оператор `$$[...]` может быть использован для получения доступа к различным опциям конфигурирования, которые были установлены при сборке Qt.

     Перечень переменных которые распознаются Qt: 

     - CONFIG

     - DESTDIR 
     - FORMS 
     - HEADERS 
     - QT 
     - RESOURCES 
     - SOURCES 
     - TEMPLATE

     **Операторы.** 

     Операторы:

     - `variable = value`

     - `variable += value`
     - `variable -= value`
     - `variable *= value`
     - `variable = value`

     `DEFINES += QT_DLL CONFIG += gui`

     **Комментарии.** 

     Для добавления комментария в файл проекта используется символ `#`. Если необходимо вставить символ `#` как часть переменной, то нужно использовать переменную.

     **Области видимости.** 

     Области видимости аналогичны операторам if в процедурных языках программирования. Если некоторое условие истинно, то объявления внутри области видимости обрабатываются.

     Области видимости допускают вложенность, а также сокращенную запись используя оператор ":". Значения, сохраненные в переменной CONFIG, специально обрабатываются для qmake.

     **Циклы.** 

     Простые циклы создаются с помощью перебора списка значений, используя встроенную функцию for. Следующий код добавляет каталоги в переменную SUBDIRS, но только в том случае, если они существуют:

     ```c++
     EXTRAS = handlers tests docs 
     for ( dir , EXTRAS) {
     	exists($$dir) {
     		SUBDIRS += $$dir 
     	}
     }
     ```

     **Встроенные и условные функции.** 

     Встроенные функции позволяют обрабатывать содержимое переменных. Эти функции обрабатывают переданные им аргументы и возвращают в качестве результата значение или список значений.

     ```c++
     HEADERS = model.h
     HEADERS += $$OTHER_HEADERS HEADERS = $$unique (HEADERS)
     win32:INCLUDEPATH += $$quote(C:/mylibs/extra headers )
     ```

     **Шаблоны проектов.** 

     Переменная TEMPLATE используется для определения типа проекта, который будет собран. Доступные типы проектов:

     - app
     - lib 
     - subdirs 
     - vcapp 
     - vclib 
     - vcsubdirs

     **Meta Object Compiler.**

     Мета-объектный компилятор(MOC) - программа, которая обрабатывает расширения C++ от Qt. Каждый класс использующий возможности мета-объектной системы должен быть обработан moc.

     Инструмент moc читает заголовочный файл C++. Если он находит одно или более объявлений классов, которые содержат макрос `Q_OBJECT`, то он порождает файл исходного кода C++, содержащий мета-объектный код для этих классов.

     Обычно moc используется с входным файлом, содержащим такое объявление класса:

     ```c++
     class Class: public QObject {Q_OBJECT};
     ```

    ---

19. **Виджеты.**

     Класс `QWidget` является фундаментальным и содержит в себе огромное количество методов и свойств, для таких каких вещей как изменение местоположения, обработки событий и т.п. 

     `QWidget` унаследован от `QObject` что позволяет использовать механизмы сигналов/слотов.

     Любой `QWidget` может являться контейнером для другого виджета. Виджеты могут иметь потомков которые будут отображаться внутри предка - это позволяет наследовать свойства виджетов расположенных на вершине иерархии, т.е. скрыв один виджет верхнего уровня автоматически скрываются все его потомки.

     Виджет без потомка называется виджетом верхнего уровня, и представляет из себя отдельное окно.

     **Свойства виджетов.**

     ```c++
     QQString windowTitle () const
     void setWindowTitle ( const QString & ) 
     QIcon windowIcon () const
     void setWindowIcon ( const QIcon & icon )
     Qt::WindowStates windowState () 
     void showNormal () [ slot ]
     bool isMinimized () const
     void showMinimized () [ slot ] 
     bool isMaximized () const
     void showMaximized () [ slot ] 
     bool isFullScreen () const
     void showFullScreen () [ slot ] 
     bool isWindowModified () const 
     void setWindowModified ( bool ) const
     QWidget* window () const
     bool isWindow () const
     QWidget* parentWidget () const 
     void setParent ( QWidget ⇤ parent )
     ```

     **Взаимоотношения виджетов.**

     ```c++
     QRect childrenRect () const
     QRegion childrenRegion () const
     QPoint mapFromParent ( const QPoint & pos ) const 
     QPoint mapToParent ( const QPoint & pos ) const 
     QPoint mapFromGlobal ( const QPoint & pos ) const 
     QPoint mapToGlobal ( const QPoint & pos ) const 
     QRegion visibleRegion () const
     Qt::WindowModality windowModality () const
     bool isEnabled () const 
     void setEnabled ( bool ) bool hasFocus () const void setFocus ( ) [ slot ] void clearFocus ()
     Qt::FocusPolicy focusPolicy () const
     void setFocusPolicy ( Qt::FocusPolicy policy ) 
     bool focusNextChild () [ protected ]
     bool focusPreviousChild () [ protected ]
     ```

     **Особенности управление памятью в Qt.**

     Для построения иерархий необходимо использовать классы, рожденные от `QObject`. Объекты классов должны создаваться динамически.

     Класс `QObject` содержит реализацию всех необходимых методов для организации иерархий объектов. Конструктор `QObject` выглядит следующим образом:

     ```c++
     QObject(QObject* parent=nullptr);
     ```

     **Создание и удаление объекетов.**

     Одно из основных достоинств иерархий объектов - это автоматическое удаление всех дочерних объектов при удалении корневого объекта. Разработчику достаточно удалить только те объекты, которые являются вершинами.

     ---

20. **Глобальные определения.**

     Содержатся в заголовочном файле `QtGlobal`

     - `qMax, qMin`
     - `qAbs, qRound`
     - `qint8, ...`

     **Методы отладки в Qt.**

     - отладчик 
     - `QObject::dumpObjectInfo()`
     - `Q_ASSERT()` - выводит предупреждение, если не равно `true`
     - `Q_CHECK_PTR()` - проверяет указатель на `NULL`
     - `qDebug(), qWarning(), qFatal()`

     В процессе отладки рекомендуется присваивать объектам имена при помощи функции `QObject::objectName()`

     **Интернациализация приложений.**

     ```q
     TRANSLATIONS = myapp_fi . t s myapp_ru . t s
     ```

     Using `QLinguist`.

     Для использования полученной интернациализации необходимо подключить транслятор в самом начале запуска приложения, где в метод `load` передается имя скомпилированного файла с передов, без расширения `qm`.

     **Способы изменения геометрии виджета.**

     ```c++
     QPoint pos () const
     QRect frameGeometry () const
     void move ( const QPoint & )
     const QRect & geometry () const 
     QRect rect () const
     void setGeometry ( const QRect & ) 
     QSize size () const
     void resize ( const QSize & )
     virtual QSize sizeHint () const
     virtual QSize minimumSizeHint () const 
     QSize minimumSize () const
     void setMinimumSize ( const QSize & )
     void setMinimumSize ( int minw, int minh ) 
     QSize sizeIncrement () const
     void setSizeIncrement ( const QSize & ) 
     void adjustSize ()
     void setFixedSize ( const QSize & s )
     ```

     **Менеджеры компоновки.**

     Qt содержит несколько классов обеспечивающих компоновку виджетов на форме: `QHBoxLayout`, `QVBoxLayout`, `QGridLayout`. 

     Менеджеры компоновки позволяют виджетам автоматически адапритироваться к изменению размеров, формы, шрифтов.

     **Ресурсы в Qt.**

     *.qrc files - XML files.

     Подключение ресурсов, в .pro файл добавить:

     ```q
     RESOURCES = application . qrc
     ```

     Использование:

     ```c++
     cutAct = new QAction(QIcon(":/images/cut.png"), tr( "Cu&t"), this);
     ```

     ---

21. **Работа со строками в Qt.** 

     Класс QString представляет собой строку символов Unicode. `QString` хранит строку 16-битных `QChar`, где каждый `QChar` хранит символ Unicode 4.0.

     Qt также предоставляет класс `QByteArray` для хранения произвольных байтов и 8-битных оканчивающихся на `\0` строк.

     **Проверка ввода.** 

     Вы можете использовать функцию строки contains, чтобы проверить, содержит ли она соответствующую подстроку.

     Для проверки сложных шаблонов можно использовать регулярные выражения.

     **Регулярные выражения.**

     Описываются классом `QRegExp`, представляют из себя шаблон который предназначен для поиска текста в строке.

     ---

22. **Контейнерные классы в Qt.** 

     Последовательные и ассоцитивные. 

     Последовательные:

     - `QVector<T>`
     - `QList<T>`
     - `QLinkedList<T>`
     - `QStack`

     - `QQueue`

     Ассоциативные:

     - `QSet<T>`
     - `QMap<K,T>`

     - `QMultiMap<K,T>`
     - `QHash<K,T>`
     - `QMultiHash<K,T>`

     **Итераторы.** 

     - `iterator`
     - `const_iterator`: Если не планируется изменять значения элементов, то эффективнее использовать `const_iterator`
     - `foreach`

     **Последовательные контейнеры.**

     - `+`
     - `+= ￿`
     -  `at()`
     - `back()` 
     - `last()`
     - `front()`
     - `first()`
     - `contains()`
     - `indexOf()`
     - `lastIndexOf()`
     - `push_back()`
     - `append()`
     - `push_front()`
     - `prepend()`

     `QVector`:

     Представляет собой динамический массив. Вставка в начало и в середину происходят за время O(n), в конец массива может выполняться за время O(1).

     `QList`:

     Представляет собой упорядоченный набор связанных друг с другом элементов. Поиск выполняется за время O(1), вставка в середину за O(n), вставка вначало или конец списка как правило за O(1), эти времена достиаются за счет того что внутри QList реализован на базе массива.

     `QLinkedList`:

     Двусвязный список. Вставка в любое место списка выполняется за время O(1), поиск за O(n).

     `QStack`:

     Стек - реализует структуру данных, работающую по принципу LIFO. Наследуется от QVector’a.

     `QQueue`:

     Стек - реализует структуру данных, работающую по принципу FIFO. Наследуется от QList’a.

     ---

23. **Контейнерные классы в Qt.** 

     > ***Same as previous one***

     **Алгоритмы работы с контейнерными классами.**

     Входят в заголовочный файл `QtAlgorithms` и предоставляют операции применяемые к контейнерам.

     - `qBinaryFind()`
     - `qCopy()` 
     - `qCopyBackward()` 
     - `qCount()` 
     - `qDeleteAll()` 
     - `qEqual()`

     - `qFill()
     - `qFind()`
     - `qLowerBound()` 
     - `qUpperBound()` 
     - `qSwap()`

     **Ассоциативные контейнеры.**

     Для всех контейнеров этого типа доступны методы: contains()

     - `erase()`
     - `find()`
     - `insert()` отсутствует в `QSet`
     - `insertMulti()` отсутствует в `QSet` 
     - `key()` отсутствует в `QSet`
     - `keys()` отсутствует в `QSet`
     - `keys()` отсутствует в `QSet`
     - `values()`

     Словари хранят элементы одного и того же типа, индексируемые ключевыми значениями, в `QMap` - ключи должны быть уникальны в отличии от `QMultiMap` (элементы словаря отсортированы по ключу). Вставка и поиск элементов осуществляются за время O(logn).

     Если необходимо связать с одним ключем несколько значений, например, в адресной книге, то необходимо использовать структуру QMultiMap.

     ---

24. **События и таймеры в Qt.** 

     События используются для оповещения объектов о возникновении/изменении каких-либо ситуаций. 

     Основными источниками событий являются элементы пользовательского интерфейса, кроме того существуют события, генерируемые системными объектами (например, таймерами). В общем случае, сразу после возникновения, событие помещается в очередь для дальнейшей обработки.

     Класс QObject содержит встроенные таймеры, которые позволяют организовать периодическое повторение определенных действий. Для использования таймеров QObject содержит следующие методы:

      - `int startTimer(int interval)`
      - `virtual void timerEvent(QTimerEvent* event)`
      - `void killTimer(int id)`

     Объект `QObject` позволяет создавать множество таймеров. При реализации потомка таймеры могут быть запущены следующим образом:

      ```c++
      timer = startTimer(1000);  // For second
      ```

     При этом виртуальный метод `timerEvent()` должен действовать в зависимости от идентификатора вызывающего таймера.

     **Перехват и обработка событий.** 

     В Qt событие - это экземпляр класса QEvent. В Qt редко приходится использовать события напрямую, т.к. большинство виджетов сами генерируют сигналы в ответ на любое существенное событие.

     События используются для оповещения объектов о возникновении/изменении каких-либо ситуаций. Основными источниками событий являются элементы пользовательского интерфейса, кроме того существуют события, генерируемые системными объектами (например, таймерами). В общем случае, сразу после возникновения, событие помещается в очередь для дальнейшей обработки.

     **Фильтры событий.**

     Настройка фильтров событий состоит из следующих этапов:

     Регистрация объекта-перехватчика с целевым объектом посредством вызова функции `installEventFilter()`.

     Обработка события в функции `eventFilter()` перехватчика.

     **Отправка событий.**

     Событие может быть инициировано прямым вызовом функции события. Когда происходит указанное действие, Qt также запускает соответствующую функцию события.

     ---

25. **Вывод графики в Qt.**

     `QPainter` может использоваться для вычерчивания на различных устройствах, таких как `QWidget`, `QPixmap`, `QImage`, `QPrinter` и т.п., что позволяет использовать один программный код для отображения на экран, получения изображения и печати отчетов.

     **Рисование на виджетах.** 

     Using `QPainter`, `QPaintEgine` with `QGraphicsSence`.

     **Модель графического представления.**

     Представляет собой программный интерфейс опирающийся на концепцию Model-View.

     Содержит в себе класс `QGraphicsScene` являющийся моделью для графических элементов, которые наследуются от `QGraphicsItem`.

     `QGraphicsView` - представление, использующееся для показа элементов модели.

     Каждый элемент `QGraphicsItem` включает в себя поддержку событий мыши, клавиатуры и позволяет: перетаскивать, группировать и определять столкновения объектов.

     ---

26. **Работа с базами данных в Qt.** 

     **Уровень драйверов.** 

     **Программный уровень.**

     **Уровень пользовательского интерфейса.** 

     **Архитектура модель-представление.**

