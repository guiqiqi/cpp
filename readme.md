1. **Различие в подходах к разработке компьютерных приложений (Структурное программирование и Объектно-ориентированное программирование).**

    Ориентированное на процесс - это идея программирования, ориентированная на процесс. 

    Сначала он анализирует шаги, необходимые для решения проблемы, а затем использует функции для пошагового выполнения этих шагов и вызывает их по очереди при их использовании. 

    Это базовое последовательное мышление. 

    Метод разработки, ориентированный на процесс, представляет собой абстракцию базовой структуры компьютера. 

    Он делит программу на две части: данные и манипулирование данными. 

    Основной проблемой является разработка и оптимизация структур данных и алгоритмов.

    **Классы: определение, область действия.**

    Область видимости (scope) представляет часть программы, в пределах которой можно использовать объект. Как правило, область видимости ограничивается блоком кода, который заключается в фигурные скобки В зависимости от области видимости создаваемые объекты могут быть глобальными, локальными или автоматическими.

    Основное назначение классов - описывать объекты реального мира, а следовательно проектирование класса эквивалентно моделированию.

    **Структуры в С и С++.**

    Мы используем struct для представления структуры на языке C и используем class в C++.

    C++предоставляет функции управления доступом и ООП для структуры классов.

    ---

2. **Последовательность преобразований исходного кода на языке C++ в исполняемый (машинный) код.** 

    Компилятор преобразует исходный код C ++ в последовательность машинного кода, этот процесс называется компиляцией.

    Процесс можно разделить на несколько частей:

    Предварительная обработка, сборка, компоновка

    **Основные концепции ООП.** 

    Данные содержватся в самом объекте, как в капсуле. 

    Главный принцип ООП - не получайте посредством объекта данные, необходимые для совершения операции. 

    Вместо этого "попросите" объект содержащий данные сделать эту операцию для Вас. 

    Этот принцип называется делегированием.

    **Понятие класса в С++.** 

    Компилятор извлекает из класса следующую информацию: новый пользовательский тип данных;

    имена и типы членов класса, включая типы переменных и прототипы функций;

    спецификаторы доступа (ограничения по использованию функций и переменных класса).

    **Инкапсуляция, наследование, полиморфизм.**

    Инкапсуляция - каждый класс представляет уникальный набор данных и операций (методов) над этими данными.

    Наследование - возможность добавления в класс новых свойств на основе базовых классов.

    Полиморфизм - получение разного поведения объектов во время выполнения посредством одного и того же кода.

    ---

3. **Доступ к элементам класса: управление доступом, функции доступа.** 

    Каждый уровень доступа к данным и функциям определяется ключевыми словами `public, private, protected`.

    Не обязательно для каждого члена класса указывать спецификатор доступа.

    По умолчанию объявлены как `private`.

    Секции с одним и тем же ключевым словом может быть сколько угодно и идти они могут в любом порядке.

    `private` и `protected` члены другого объекта такого же класса будут внутри всех методов класса.

    **Инициализация объектов класса: конструкторы. деструкторы.** 

    Конструктор - Метод, который вызывается компилятором автоматиечски при создании объекта.

    - нельзя вызвать явно, как обычный метод;

    - имя конструктора всегда сопадает с именем класса;

    - у конструктора отсутсвует тип возвращаемого значения, даже void;

    - конструктор не может быть константным, виртуальным или статическим методом.

    Деструктор

    - в большинстве случаев вызывается компилятором неявно; 

    - можно вызвать явно, как метод;
    - имя деструктора совпадает с именем класса, но с символом ~;

    - не принимает параметров и ничего не возвращает; 

    - не может быть константным или статическим; 

    - может быть виртуальным.

    **Константные объекты и функции-элементы класса, вложенность классов, указатель this.** 

    Мы можем включить другой экземпляр класса в качестве переменной-члена класса.

    Указатель this формируется компилятором внутри нестатических методов, следовательно использовать его можно только внутри класса.

    Для класса A тип указателя this - `A* const`.

    **Динамическое распределение памяти.**

    Динамическая память находится в куче памяти программы.

    Динамически выделяемая память не управляется автоматически компилятором, и программист должен освободить ее вручную. Как правило, динамическая память необходима, когда размер используемой памяти неизвестен.

    ---

4. **Указатели и массивы.**

    Имя массива в языке С фактически является указателем на первый его элемент, который соответствует нулевому значению индекса. Если объявлен массив `float a[16];`, то справедливо равенство `а==&a[0]`.

    **Многомерные массивы.**

    

    **Массивы указателей.**

    

    **Указатели и ссылки на объекты.** 

    

    **Операции приведения типов.** 

    

    **Способы обработки исключительных ситуаций.**

    

5. **Передача объектов в функции.**

     

    **Возвращение объектов.**

    

    **Модификаторы доступа и дружественные функции, дружественные классы.**

    

    **Переопределение операций.**

    

    **Операции в виде методов класса и в виде дружественных функций.**

    

6. **Особенности переопределение унарныхи бинарных операций.**

     

    **Наследование: базовые и производные классы.**

    

    **Переопределение элементов базового класса. Модификаторы наследования и модификаторы доступа, их сочетание.**

    

7. **Прямые и косвенные базовые классы, множественное наследование.** 

     

    **Конструкторы и деструкторы производных классов, неявный и явный вызовы.** 

    

    **Виртуальные функции, динамическое связывание, деструкторы.** 

    

    **Абстрактные классы.**

    

8. **Потоковый ввод-вывод, функции работы с потоками.**

     

    **Классы и объекты потоков ввода-вывода (библиотеки STL).** 

    

    **Ввод-вывод типов данных, определенных пользователем.** 

    

    **Методы работы с файлами.**

    

9. **Особенности работы со строками текста.**

     

    **Класс string библиотеки STL.**

    

    **Пример разбора текста.**

    

    **Шаблоны функций, переопределение функций шаблона.**

    

10. **Шаблоны классов.**

    

    **Пример разработки шаблона универсальной коллекции типа array (list).**

    

11. **Статические члены класса.** 

     

     **Особенности определения.** 

     

     **Пространства имен в C++.** 

     

     **Компоненты библиотеки STL.** 

     

     **Контейнеры STL.**

     

12. **Методы обработки ошибок в С++.** 

     

     **Генерация и перехват исключений, обработчики исключений.** 

     

     **Классы-индикаторы исключений, иерархия исключений.**

     

13. **Итераторы, их типы и применение (библиотека STL).** 

     

     **Примеры использования класса vector (библиотека STL).** 

     

     **Типизированные и обобщенные последовательности (коллекции) данных.**
